Struttura progetto:
1) Struttura globale di ogni oggetto e implementazione di ogni schermata
- Assicurarsi che si chiuda alla funzione close() 
- Abbinare ogni oggetto ad un numero da poi inserire in ogni tile dell'array (vedi 2.Functions)) con una funzione e switch statements
- Abbinare, con una funzione e switch statements, ogni numero ad un oggetto da poi usare nelle funzioni

1.Object)
- costruire una class con nested (enum class Type (dove si raggruppano tutti i nomi dei possibili oggetti e l'oggetto vuoto) )
- Movimento: Check stop/push, check movable, move into (se Ã¨ muro o fine mappa)

2)

2.Functions)
- funzione clear(): per resettare la schermata
- funzione draw(): per, una volta sistemato tutti gli oggetti e le relative posizioni
- funzione display() (mandatory dopo draw()): it takes what was drawn since the last call to display and displays it on the window
- 

2. Struttura dei file)
- Creare per ogni livello due file (un header (per le dichiarazioni della posizione) e un sorgente (definizioni del tipo di ogni oggetto)) 
- Ogni livello: update della schermata (dal file sorgente)
  Creare una grid e riempirla di oggetti
  Assicurarsi della correttezza delle frasi logiche
- quando si registra un input, registrare tutti i cambiamenti logici e agire su di essi
Al raggiungimento delle condizioni dell'evento win, distruggi il livello e rimpiazzalo con una schermata con "Hai vinto!" e tempo usato. Mettere un tasto per chiudere il programma o continuare (se altri livelli)
Al raggiungimento delle condizioni dell'evento lose, distruggi il livello e rimpiazzalo con una schermata con "Hai perso!" e tempo usato. Mettere un tasto per chiudere il programma o ricominciare
